-file("./ecirca.erl", 1).

-module(ecirca).

-file("./ecirca.hrl", 1).

-file("./ecirca.erl", 24).

-export([new/3]).

-export([get/2,slice/3]).

-export([set/3,update/3,push/2,push_many/3,push_list/2]).

-export([max_slice/1,max_size/1]).

-export([size/1]).

-export([load/2,save/1]).

-export([nif_init/0,not_loaded/1]).

-export_types([{res,0},{maybe_value,0},{value,0}]).

-opaque ecirca() :: {ecirca, resource(), pid(), ecirca_value_size()}.

-type resource() :: <<>>.

-type value() :: non_neg_integer().

-type maybe_value() :: value() | empty.

-type nonneg() :: non_neg_integer().

-type ecirca_type() :: last | max | min | avg | sum.

-type ecirca_value_size() :: small | medium | large.

-spec new(pos_integer(), ecirca_type(), ecirca_value_size()) ->
             {ok, ecirca()} | {error, max_size}.

new(Size, Type, small) ->
    ecirca_small:new(Size, Type);
new(Size, Type, medium) ->
    ecirca_medium:new(Size, Type);
new(Size, Type, large) ->
    ecirca_large:new(Size, Type).

-spec set(ecirca(), pos_integer(), maybe_value()) -> {ok, maybe_value()}.

set({_,Res,Pid,small}, Position, Value) ->
    case self() == Pid of
        true ->
            ecirca_small:set(Res, Position, Value);
        false ->
            {error,cretor_only}
    end;
set({_,Res,Pid,medium}, Position, Value) ->
    case self() == Pid of
        true ->
            ecirca_medium:set(Res, Position, Value);
        false ->
            {error,cretor_only}
    end;
set({_,Res,Pid,large}, Position, Value) ->
    case self() == Pid of
        true ->
            ecirca_large:set(Res, Position, Value);
        false ->
            {error,cretor_only}
    end.

-spec update(ecirca(), pos_integer(), maybe_value()) ->
                {ok, maybe_value()}.

update({_,Res,Pid,small}, Position, Value) ->
    case self() == Pid of
        true ->
            ecirca_small:update(Res, Position, Value);
        false ->
            {error,cretor_only}
    end;
update({_,Res,Pid,medium}, Position, Value) ->
    case self() == Pid of
        true ->
            ecirca_medium:update(Res, Position, Value);
        false ->
            {error,cretor_only}
    end;
update({_,Res,Pid,large}, Position, Value) ->
    case self() == Pid of
        true ->
            ecirca_large:update(Res, Position, Value);
        false ->
            {error,cretor_only}
    end.

-spec push(ecirca(), maybe_value()) -> ok.

push({_,Res,Pid,small}, Value) ->
    case self() == Pid of
        true ->
            ecirca_small:push(Res, Value);
        false ->
            {error,cretor_only}
    end;
push({_,Res,Pid,medium}, Value) ->
    case self() == Pid of
        true ->
            ecirca_medium:push(Res, Value);
        false ->
            {error,cretor_only}
    end;
push({_,Res,Pid,large}, Value) ->
    case self() == Pid of
        true ->
            ecirca_large:push(Res, Value);
        false ->
            {error,cretor_only}
    end.

-spec push_many(ecirca(), nonneg(), maybe_value()) -> {ok, ecirca()}.

push_many(Res, N, Val) ->
    [ 
     push(Res, Val) ||
         _ <- lists:seq(1, N)
    ],
    {ok,Res}.

-spec push_list(ecirca(), [maybe_value()]) -> {ok, ecirca()}.

push_list(_Ecirca, _Lst) ->
    {ok,<<>>}.

-spec get(ecirca(), pos_integer()) -> {ok, maybe_value()}.

get({_,Res,Pid,small}, Position) ->
    case self() == Pid of
        true ->
            ecirca_small:get(Res, Position);
        false ->
            {error,cretor_only}
    end;
get({_,Res,Pid,medium}, Position) ->
    case self() == Pid of
        true ->
            ecirca_medium:get(Res, Position);
        false ->
            {error,cretor_only}
    end;
get({_,Res,Pid,large}, Position) ->
    case self() == Pid of
        true ->
            ecirca_large:get(Res, Position);
        false ->
            {error,cretor_only}
    end.

-spec slice(ecirca(), pos_integer(), pos_integer()) ->
               {ok, [maybe_value()]} | {error, slice_too_big}.

slice({_,Res,Pid,small}, Start, End) ->
    case self() == Pid of
        true ->
            ecirca_small:slice(Res, Start, End);
        false ->
            {error,cretor_only}
    end;
slice({_,Res,Pid,medium}, Start, End) ->
    case self() == Pid of
        true ->
            ecirca_medium:slice(Res, Start, End);
        false ->
            {error,cretor_only}
    end;
slice({_,Res,Pid,large}, Start, End) ->
    case self() == Pid of
        true ->
            ecirca_large:slice(Res, Start, End);
        false ->
            {error,cretor_only}
    end.

-spec max_size(ecirca_value_size()) -> {ok, pos_integer()}.

max_size(small) ->
    ecirca_small:max_size();
max_size(medium) ->
    ecirca_medium:max_size();
max_size(large) ->
    ecirca_large:max_size().

-spec max_slice(ecirca_value_size()) -> {ok, pos_integer()}.

max_slice(small) ->
    ecirca_small:max_slice();
max_slice(medium) ->
    ecirca_medium:max_slice();
max_slice(large) ->
    ecirca_medium:max_slice().

-spec size(ecirca()) -> {ok, pos_integer()}.

size({_,Res,Pid,small}) ->
    case self() == Pid of
        true ->
            ecirca_small:size(Res);
        false ->
            {error,cretor_only}
    end;
size({_,Res,Pid,medium}) ->
    case self() == Pid of
        true ->
            ecirca_medium:size(Res);
        false ->
            {error,cretor_only}
    end;
size({_,Res,Pid,large}) ->
    case self() == Pid of
        true ->
            ecirca_large:size(Res);
        false ->
            {error,cretor_only}
    end.

-spec load(binary(), ecirca_value_size()) ->
              {ok, ecirca()} | {error, wrong_ecirca_value_type}.

load(Binary, small) ->
    ecirca_small:load(Binary);
load(Binary, medium) ->
    ecirca_medium:load(Binary);
load(Binary, large) ->
    ecirca_large:load(Binary).

-spec save(ecirca()) -> {ok, binary()}.

save({_,Res,Pid,small}) ->
    case self() == Pid of
        true ->
            ecirca_small:save(Res);
        false ->
            {error,cretor_only}
    end;
save({_,Res,Pid,medium}) ->
    case self() == Pid of
        true ->
            ecirca_medium:save(Res);
        false ->
            {error,cretor_only}
    end;
save({_,Res,Pid,large}) ->
    case self() == Pid of
        true ->
            ecirca_large:save(Res);
        false ->
            {error,cretor_only}
    end.

-spec nif_init() -> ok | {error, _}.

nif_init() ->
    SoPrefix =
        case code:priv_dir(ecirca) of
            {error,bad_name} ->
                case filelib:is_dir(filename:join(["..",priv])) of
                    true ->
                        filename:join(["..",priv,ecirca]);
                    _ ->
                        filename:join([priv,ecirca])
                end;
            Dir ->
                filename:join(Dir, ecirca)
        end,
    SoRets =
        [ 
         erlang:load_nif(SoPrefix ++ "_" ++ atom_to_list(X), 1) ||
             X <- [small,medium,large]
        ],
    case
        lists:foldl(fun(ok, Acc) ->
                           Acc;
                       ({error,Reason}, Acc) ->
                           [Reason|Acc]
                    end,
                    [],
                    SoRets)
    of
        [] ->
            ok;
        Lst ->
            {error,Lst}
    end.

-spec not_loaded(pos_integer()) -> ok.

not_loaded(Line) ->
    exit({not_loaded,[{module,ecirca},{line,Line}]}).



